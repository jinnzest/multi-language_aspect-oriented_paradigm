## Multi-language - is a programming paradigm to create faster and more durable applications thanks to the automation of routine tasks and reducing complexity by splitting a programming language into several linked languages.  

All programming languages created till the moment attempted to express complex and multilayered concepts using flat text. Thus business logic is always mixed with such language means as low-level memory management means (or even high-level automated ones), execution speed control means, different means increasing the durability of code, etc. Designing a language that handles all those aspects simultaneously makes it very difficult to use it, and the threshold of entry to it is very high. Designing a language handling subset of aspects leads to the combinatorial explosion of specialized languages that can do well only one thing and that a developer has to integrate somehow. Such combinatorial explosion forces a programmer to learn many languages to develop even a single project. It complicates recruiting a development team for a project (and makes it more expensive than it could be). And since each language has its specifics and pitfalls, this reduces the reliability of a system written simultaneously in many programming languages.

Extraction of the minimal core, which any programmer can learn as quickly as possible that does not have implicit and complex behavior, allows a software developer to write programs as fast as possible. Extraction of an auxiliary language responsible for memory management and hardware-dependent optimizations allows writing the most efficient programs without cluttering the business logic code. Extraction of an auxiliary validation language allows validation without complicating the business logic code. The same is true for various other aspects of programming such as algorithmic complexity, memory complexity, etc.

For some auxiliary languages, it is possible to have a separate developer specializing in this aspect of a system (such as the speed optimizer). For that projects for which some aspect is not that important, developers can use the default behavior, which is less effective than the one configured by a person but can do without an additional specialist. A developer can configure a set of auxiliary languages at the beginning of a project and then add or remove any such language later (When a developer disables some aspect, then multi-language stops generating analytics but still generates default directives). In addition, it is possible to use auxiliary languages (directives affecting generated code) not for a whole software project but only for specific components. For example, there is no point in optimizing the speed for an entire codebase. Therefore, a developer can use default directives for most parts of a software project and then optimize the most critical pieces only. Etc.

Each of the auxiliary languages, in addition to effect generated machine code, also generates different analytics. Thus, in contrast to other programming languages, where a programmer needs to keep in mind various aspects of the behavior of a particular language, in a multi-language, all the features of behavior can be checked in the corresponding analytics without being distracted by related aspects. As a result, a programmer does not need to analyze every line of a program from all aspects simultaneously, trying to guess what that line does at runtime. It is enough for a developer to check generated analytics for a system part to check that a directive was applied correctly. 

You can learn more details and recommendations on a multi-language design in the [Multi-Language Manifesto](https://github.com/jinnzest/aspectation-manifesto/blob/master/manifesto.md). 
